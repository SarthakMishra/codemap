"""Markdown documentation generation for the CodeMap tool."""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from pathlib import Path


class MarkdownGenerator:
    """Generates markdown documentation from parsed code files."""

    def __init__(self, repo_root: Path, config: dict[str, Any]) -> None:
        """Initialize the markdown generator.

        Args:
            repo_root: Root directory of the repository.
            config: Configuration dictionary for documentation generation.
        """
        self.repo_root = repo_root
        self.config = config

    def _generate_file_tree(self) -> str:
        """Generate a tree representation of the repository structure."""
        tree = ["```"]

        def add_to_tree(path: Path, prefix: str = "") -> None:
            if path.is_file():
                tree.append(f"{prefix}├── {path.name}")
            else:
                tree.append(f"{prefix}└── {path.name}/")
                for child in sorted(path.iterdir()):
                    add_to_tree(child, prefix + "    ")

        add_to_tree(self.repo_root)
        tree.append("```")
        return "\n".join(tree)

    def _generate_overview(self, parsed_files: dict[Path, dict[str, Any]]) -> str:
        """Generate overview section.

        Args:
            parsed_files: Dictionary mapping file paths to their parsed contents.

        Returns:
            Generated overview section.
        """
        overview = ["## Overview\n"]
        overview.append("This documentation was generated by CodeMap.\n")
        overview.append(f"Total files analyzed: {len(parsed_files)}\n")
        return "\n".join(overview)

    def _generate_dependencies(self, parsed_files: dict[Path, dict[str, Any]]) -> str:
        """Generate dependencies section.

        Args:
            parsed_files: Dictionary mapping file paths to their parsed contents.

        Returns:
            Generated dependencies section.
        """
        deps = ["## Dependencies\n"]
        all_imports = set()
        for symbols in parsed_files.values():
            all_imports.update(symbols.get("imports", []))

        if all_imports:
            deps.append("### External Dependencies\n")
            deps.extend(f"- {imp}" for imp in sorted(all_imports))

        return "\n".join(deps)

    def _generate_file_documentation(self, symbols: dict[str, Any]) -> str:
        """Generate documentation for a single file.

        Args:
            symbols: Dictionary containing parsed symbols from the file.

        Returns:
            Generated markdown documentation for the file.
        """
        docs = []

        if "docstring" in symbols:
            docs.append(symbols["docstring"])
            docs.append("")

        if "classes" in symbols:
            for class_name in symbols["classes"]:
                docs.append(f"#### {class_name}")
                docs.append("")

        if "functions" in symbols:
            for func_name in symbols["functions"]:
                docs.append(f"#### {func_name}")
                docs.append("")

        return "\n".join(docs)

    def _escape_markdown(self, text: str) -> str:
        """Escape markdown special characters.

        Args:
            text: Text to escape.

        Returns:
            Escaped text.
        """
        special_chars = ["*", "_", "#", "`", "[", "]", "(", ")", ">", "+", "-", ".", "!"]
        escaped_text = text
        for char in special_chars:
            escaped_text = escaped_text.replace(char, f"\\{char}")
        return escaped_text

    def generate_documentation(self, parsed_files: dict[Path, dict[str, Any]]) -> str:
        """Generate markdown documentation from parsed files.

        Args:
            parsed_files: Dictionary mapping file paths to their parsed contents.

        Returns:
            Generated markdown documentation as a string.
        """
        markdown = ["# Code Documentation\n"]

        # Generate sections based on config
        sections = self.config.get("sections", ["overview", "dependencies", "details"])

        for section in sections:
            if section == "overview":
                markdown.append(self._generate_overview(parsed_files))
            elif section == "dependencies":
                markdown.append(self._generate_dependencies(parsed_files))
            elif section == "details":
                # Sort files by importance score if available
                sorted_files = sorted(
                    parsed_files.items(),
                    key=lambda x: x[1].get("importance_score", 0),
                    reverse=True,
                )

                markdown.append("## Details\n")
                for file_path, symbols in sorted_files:
                    rel_path = file_path.relative_to(self.repo_root)
                    markdown.append(f"\n### {rel_path}\n")
                    file_docs = self._generate_file_documentation(symbols)
                    markdown.append(self._escape_markdown(file_docs))
            else:
                # Custom section
                section_title = section.replace("_", " ").title()
                markdown.append(f"## {section_title}\n")

        return "\n".join(markdown)
