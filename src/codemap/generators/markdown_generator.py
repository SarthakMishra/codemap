"""Markdown documentation generation for the CodeMap tool."""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from pathlib import Path


class MarkdownGenerator:
    """Generates markdown documentation from parsed code files."""

    def __init__(self, repo_root: Path, config: dict[str, Any]) -> None:
        """Initialize the markdown generator.

        Args:
            repo_root: Root directory of the repository.
            config: Configuration dictionary for documentation generation.
        """
        self.repo_root = repo_root
        self.config = config

    def _generate_file_tree(self) -> str:
        """Generate a tree representation of the repository structure."""
        tree = ["```"]

        def add_to_tree(path: Path, prefix: str = "") -> None:
            if path.is_file():
                tree.append(f"{prefix}├── {path.name}")
            else:
                tree.append(f"{prefix}└── {path.name}/")
                for child in sorted(path.iterdir()):
                    add_to_tree(child, prefix + "    ")

        add_to_tree(self.repo_root)
        tree.append("```")
        return "\n".join(tree)

    def _generate_overview(self, parsed_files: dict[Path, dict[str, Any]]) -> str:
        """Generate overview section.

        Args:
            parsed_files: Dictionary mapping file paths to their parsed contents.

        Returns:
            Generated overview section.
        """
        overview = ["## Overview\n"]
        overview.append("This documentation was generated by CodeMap.\n")
        overview.append(f"Total files analyzed: {len(parsed_files)}\n")
        return "\n".join(overview)

    def _generate_dependencies(self, parsed_files: dict[Path, dict[str, Any]]) -> str:
        """Generate dependencies section.

        Args:
            parsed_files: Dictionary mapping file paths to their parsed contents.

        Returns:
            Generated dependencies section.
        """
        deps = ["## Dependencies\n"]
        all_imports = set()
        for symbols in parsed_files.values():
            all_imports.update(symbols.get("imports", []))

        if all_imports:
            deps.append("### External Dependencies\n")
            deps.extend(f"- {imp}" for imp in sorted(all_imports))

        return "\n".join(deps)

    def _get_language_for_file(self, file_path: Path) -> str:
        """Get the markdown code block language identifier based on file extension.

        Args:
            file_path: Path to the file.

        Returns:
            Language identifier for markdown code block.
        """
        extension_map = {
            ".py": "python",
            ".js": "javascript",
            ".jsx": "javascript",
            ".ts": "typescript",
            ".tsx": "typescript",
            ".java": "java",
            ".go": "go",
            ".rs": "rust",
            ".rb": "ruby",
            ".php": "php",
            ".cs": "csharp",
            ".cpp": "cpp",
            ".c": "c",
            ".h": "c",
            ".hpp": "cpp",
            ".sh": "bash",
            ".yaml": "yaml",
            ".yml": "yaml",
            ".json": "json",
            ".md": "markdown",
            ".html": "html",
            ".css": "css",
            ".scss": "scss",
            ".sql": "sql",
            ".xml": "xml",
            ".toml": "toml",
        }
        return extension_map.get(file_path.suffix.lower(), "")

    def _escape_markdown(self, text: str) -> str:
        """Escape markdown special characters that could affect formatting.

        Only escapes characters that could be interpreted as markdown syntax
        in regular text (not in code blocks or headings).

        Args:
            text: Text to escape.

        Returns:
            Escaped text.
        """
        # Only escape characters that could be interpreted as markdown syntax
        # in regular text (not in code blocks or headings)
        special_chars = ["*", "_", "`"]  # These are the main ones that affect inline formatting
        escaped_text = text
        for char in special_chars:
            escaped_text = escaped_text.replace(char, f"\\{char}")
        return escaped_text

    def _generate_file_documentation(self, file_path: Path, symbols: dict[str, Any]) -> str:
        """Generate documentation for a single file.

        Args:
            file_path: Path to the file being documented.
            symbols: Dictionary containing parsed symbols from the file.

        Returns:
            Generated markdown documentation for the file.
        """
        docs = []

        if "docstring" in symbols:
            # Escape docstrings since they can contain markdown formatting
            docs.append(self._escape_markdown(symbols["docstring"]))
            docs.append("")

        if "content" in symbols:
            language = self._get_language_for_file(file_path)
            docs.append(f"```{language}")
            docs.append(symbols["content"])
            docs.append("```")
            docs.append("")

        if "classes" in symbols:
            for class_name in symbols["classes"]:
                # No need to escape in headings
                docs.append(f"#### {class_name}")
                docs.append("")

        if "functions" in symbols:
            for func_name in symbols["functions"]:
                # No need to escape in headings
                docs.append(f"#### {func_name}")
                docs.append("")

        return "\n".join(docs)

    def generate_documentation(self, parsed_files: dict[Path, dict[str, Any]]) -> str:
        """Generate markdown documentation from parsed files.

        Args:
            parsed_files: Dictionary mapping file paths to their parsed contents.

        Returns:
            Generated markdown documentation as a string.
        """
        markdown = ["# Code Documentation\n"]

        # Generate sections based on config
        sections = self.config.get("sections", ["overview", "dependencies", "details"])

        for section in sections:
            if section == "overview":
                markdown.append(self._generate_overview(parsed_files))
            elif section == "dependencies":
                markdown.append(self._generate_dependencies(parsed_files))
            elif section == "details":
                # Sort files by importance score if available
                sorted_files = sorted(
                    parsed_files.items(),
                    key=lambda x: x[1].get("importance_score", 0),
                    reverse=True,
                )

                markdown.append("## Details\n")
                for file_path, symbols in sorted_files:
                    rel_path = file_path.relative_to(self.repo_root)
                    # No need to escape in headings
                    markdown.append(f"\n### {rel_path}\n")
                    file_docs = self._generate_file_documentation(file_path, symbols)
                    markdown.append(file_docs)
            else:
                # Custom section
                section_title = section.replace("_", " ").title()
                markdown.append(f"## {section_title}\n")

        return "\n".join(markdown)
